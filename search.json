[{"path":"https://duncanobrien.github.io/EWSmethods/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 EWSmethods authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/articles/ews_assessments.html","id":"about-this-tutorial","dir":"Articles","previous_headings":"","what":"About this tutorial","title":"Performing Early Warning Signal Assessments","text":"tutorial introduces perform univariate multivariate early warning signal (EWS) assessments using EWSmethods. give examples rolling expanding window approaches univariate data, introduce trait-based composite EWSs conclude example multivariate EWSs. Greater detail function can found Reference page.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/articles/ews_assessments.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"Performing Early Warning Signal Assessments","text":"","code":"set.seed(123) #to ensure reproducible data  library(EWSmethods)"},{"path":"https://duncanobrien.github.io/EWSmethods/articles/ews_assessments.html","id":"the-data","dir":"Articles","previous_headings":"Getting started","what":"1. The data","title":"Performing Early Warning Signal Assessments","text":"EWSmethods comes bundled two data objects allow practice using uniEWS() multiEWS() functions transitioning non-transitioning data applying use case. \"simTransComms\" contains three replicate datasets simulated five species community driven transition introduction invasive species (following Dakos 2018). multivariate dataset using multiEWS() although may also use time series isolation uniEWS(). \"CODrecovery\" contains three replicate datasets simulated cod ( Gadus morhua ) population transitions overfished recovered state following relaxation fishing pressure. data first published Clements et al. 2019. univariate, \"CODrecovery\" provides extra information body size cod individuals improve composite EWSs estimated uniEWS(). can visualise community datasets using code :   plots show transition takes place time ~= 180 \"simTransComms$1_5_1\" year ~= 2050 \"CODrecovery$1_20\". EWSmethods helpfully provides information dataset inflection_pt column. However, EWS assessments meaningful performed data prior transition. EWsmethods provides time point transition datasets, can truncate time series pre-transition data . reality, EWSs assessed real-time presence past/present tipping points often unknown. past transitions known occurred, may prudent follow suggestions O’Brien & Clements (2021) show occurrence historic transition can mask oncoming event using data post historic transition improves EWS reliability. Now data loaded truncated, can now passed uniEWS() multiEWS() perform EWS assessments.","code":"#Load the two datasets in to the session data(\"simTransComms\")  data(\"CODrecovery\") matplot(simTransComms$`1_5_1`[,3:7], type = \"l\", xlab = \"Time\", ylab = \"Density\",  main = \"Transitioning five species community\") plot(x = CODrecovery$`1_20`$time, y = CODrecovery$`1_20`$biomass, type = \"l\", xlab = \"Year\", ylab = \"Abundance\", main = \"Recovering cod population\") pre_simTransComms <- subset(simTransComms$`1_5_1`,time < inflection_pt)  pre_CODrecovery <- subset(CODrecovery$`1_20`,time < inflection_pt)"},{"path":"https://duncanobrien.github.io/EWSmethods/articles/ews_assessments.html","id":"univariate-ewss","dir":"Articles","previous_headings":"Getting started","what":"2. Univariate EWSs","title":"Performing Early Warning Signal Assessments","text":"EWSmethods provides two computational approaches calculate univariate EWSs via uniEWS() function - rolling vs expanding windows. difference two evident figure simply, rolling windows estimate EWSs subsets overall time series ‘rolling’ one data point reassessing, Conversely, expanding windows add data points sequentially ‘expanding’ assessment standardises running mean standard deviation previous window. Rolling () vs expanding (C) window concept diagram. Panels B D introduce circumstance ‘warning’ signalled approaches  computational approaches able calculate EWS indicators. brief outline can found following table well reference code uniEWS() metrics = argument.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/articles/ews_assessments.html","id":"rolling-windows","dir":"Articles","previous_headings":"Getting started > 2. Univariate EWSs","what":"Rolling windows","title":"Performing Early Warning Signal Assessments","text":"rolling window approach commonly used form EWS computation due work Dakos et al 2012 earlywarnings package. uniEWS() accepts method = winsize = argument calls expanding window method creates rolling window winsize% total time series length. Lets use example interested autocorrelation, variance skewness one five species pre_simTransComms. First supply dataframe/matrix n x 2 dimensions (first column equally time sequence second abundance/biomass time series) EWS indicator metrics. remaining arguments specify form computation, window size plotting characteristics.  Note EWS indicators begin trend upwards time ~= 170 results positive Kendall Tau correlation coefficient indicative oncoming transition/tipping point.","code":"rolling_ews_eg <- uniEWS(data = pre_simTransComms[,c(2,5)],                          metrics = c(\"ar1\",\"SD\",\"skew\"),                          method = \"rolling\",                          winsize = 50,                          y_lab = \"Density\",                          ggplotIt = TRUE)"},{"path":"https://duncanobrien.github.io/EWSmethods/articles/ews_assessments.html","id":"expanding-windows","dir":"Articles","previous_headings":"Getting started > 2. Univariate EWSs","what":"Expanding windows","title":"Performing Early Warning Signal Assessments","text":"Let’s explore alternative expanding window approach. need change uniEWS() method = argument, replace winsize = burn_in =. Instead specifying size rolling window, burn_in = dictates number datapoints uniEWS() use ‘train’ algorithm. mitigates high number false-positive signals resulting short time series length high variability data points supplied beginning assessment (O’Brien & Clements, 2021).  Similar rolling window approach, EWS indicators calculated expanding windows exceeded 2σ threshold two consecutive time points thus identified warnings time ~= 170. However confident conclusion composite metrics also display warning (ar1 + SD + skew). composite metrics simple sum standardised individual indicator strengths together known provide reliable signal lone indicators (Clements & Ozgul, 2016).","code":"expanding_ews_eg <- uniEWS(data = pre_simTransComms[,c(2,5)],                          metrics = c(\"ar1\",\"SD\",\"skew\"),                          method = \"expanding\",                          burn_in = 50,                          threshold = 2,                          y_lab = \"Density\",                          ggplotIt = TRUE) #> Warning: Removed 7 row(s) containing missing values (geom_path). #> Warning: Removed 7 rows containing missing values (geom_point)."},{"path":"https://duncanobrien.github.io/EWSmethods/articles/ews_assessments.html","id":"trait-information","dir":"Articles","previous_headings":"Getting started > 2. Univariate EWSs","what":"Trait information","title":"Performing Early Warning Signal Assessments","text":"final contribution uniEWS() ability integrate multiple information sources assessment. example, including body size estimates improves assessment reliability reducing false positive rate whilst increasing number true positives (Clements Ozgul 2016, Baruah et al. 2020). uniEWS() consequently accepts trait = argument additional trait time series can combined abundance-based EWSs composite metric. capability available method = \"expanding\" metrics = contains \"trait\"","code":"trait_ews_eg <- uniEWS(data = pre_CODrecovery[,c(2,3)],                          metrics = c(\"ar1\",\"SD\",\"trait\"), #note \"trait\" is provided here                          method = \"expanding\",                          trait = pre_CODrecovery$mean.size, #and here                          burn_in = 15, #small burn_in due to shorter time series                          threshold = 2,                          y_lab = \"Density\",                          trait_lab = \"Mean size (g)\",                          ggplotIt = TRUE) #> Warning: Removed 217 row(s) containing missing values (geom_path). #> Warning: Removed 7 row(s) containing missing values (geom_path). #> Warning: Removed 7 rows containing missing values (geom_point)."},{"path":"https://duncanobrien.github.io/EWSmethods/articles/ews_assessments.html","id":"multivariate-ewss","dir":"Articles","previous_headings":"Getting started","what":"3. Multivariate EWSs","title":"Performing Early Warning Signal Assessments","text":"powerful informative form EWS multivariate EWSs. indicators combine multiple time series/measurements focal system provide community level assessment transition risk. two primary forms multivariate EWS, averaged univariate EWS across time series assessments made dimension reduction representative time series. brief outline can found following table well reference code multEWS() metrics = argument. See Weinans et al. (2021) rigorous testing multivariate EWSs simulated system. Using multiEWS() can estimate multivariate indicators way uniEWS() - specifying method =, winsize = /burn_in = - must provide n x m dataframe/matrix representative time series. first column must equally spaced time sequence. rolling window assessment therefore coded :  Many indicators postively correlated time therefore ‘warnings’. also use expanding windows achieve similar result. Note - composite metric computed multiEWS() currently unknown combining multivariate EWS indicators influences prediction reliability.  circumstance, many indicators warning different times (e.g. \"eigenMAF\" time ~= 65 \"meanAR\" time ~= 100) vast majority warning last 20 time points. highlights usefulness expanding windows rolling exact time point warning can determined, supports Weinans et al.’s (2021) suggestion superior multivariate EWS indicator; best fit depends scenario system subject t0.","code":"multi_ews_eg <- multiEWS(data = pre_simTransComms[,2:7],                          metrics = c(\"meanAR\",\"maxAR\",\"meanSD\",\"maxSD\",\"eigenMAF\",\"mafAR\",\"mafSD\",\"pcaAR\",\"pcaSD\",\"eigenCOV\",\"maxCOV\",\"mutINFO\"),                          method = \"rolling\",                          winsize = 50,                          ggplotIt = TRUE) multi_ews_eg2 <- multiEWS(data = pre_simTransComms[,2:7],                          method = \"expanding\",                          burn_in = 50,                          threshold = 2,                          ggplotIt = TRUE) #> Warning: Removed 24 row(s) containing missing values (geom_path). #> Warning: Removed 24 rows containing missing values (geom_point)."},{"path":[]},{"path":[]},{"path":"https://duncanobrien.github.io/EWSmethods/articles/ews_assessments.html","id":"rolling-windows-1","dir":"Articles","previous_headings":"FAQ > 1. How do I interpret EWSs?","what":"Rolling windows","title":"Performing Early Warning Signal Assessments","text":"simplicity rolling window approach also limits usefulness. ‘warning’ indicated EWS displays strong positive Kendall Tau correlation time. However, unclear constitutes ‘strong’ correlation context published warnings ranging 0.5 0.9 (Dakos et al. 2012, Dablander et al. 2022, Southall et al. 2022). strength correlation therefore appears context dependent system specific. alternative approach suggested Dakos et al. (2012) generate random permutations assessed time series compare estimated Kendall Tau coefficients ‘true’ time series. true coefficient stronger 95% permuted coefficients represents warning.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/articles/ews_assessments.html","id":"expanding-windows-1","dir":"Articles","previous_headings":"FAQ > 1. How do I interpret EWSs?","what":"Expanding windows","title":"Performing Early Warning Signal Assessments","text":"Expanding windows stronger evidence base constitutes ‘warning’. Clements et al. 2019 show two consecutive transgressions 2σ threshold reduce false-postive rates improve number true-postives. validated Southall et al. 2022 although suggest two consecutive signals aimed .","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/articles/ews_assessments.html","id":"do-i-need-to-detrend-my-data","dir":"Articles","previous_headings":"FAQ","what":"2. Do I need to detrend my data?","title":"Performing Early Warning Signal Assessments","text":"body work suggests detrending may necessary improve reliability early warning signal indicators (Dakos et al. 2012, Gama Dessavre et al. 2019, Lenton et al. 2012). EWSmethods therefore provides simple detrending function detrend_ts() provides four methods detrending time series: Example:  current consensus detrending required prior univariate EWS analysis. However non-average multivariate indicators, suggest assessments made non-detrended data trend informative. Mutual information particular suffers following detrending.","code":"detrend_dat <- detrend_ts(data =  pre_simTransComms[,2:7],  method = \"loess\", span = 0.75, degree = 2)  matplot(x = detrend_dat$time, y = detrend_dat[,2:6], type = \"l\", xlab = \"Date\", ylab = \"Density\",  main = \"LOESS detrended five species community\")"},{"path":"https://duncanobrien.github.io/EWSmethods/articles/ews_assessments.html","id":"my-data-is-seasonalcontains-cycles--can-i-still-use-early-warning-signals","dir":"Articles","previous_headings":"FAQ","what":"3. My data is seasonal/contains cycles. Can I still use Early Warning Signals?","title":"Performing Early Warning Signal Assessments","text":"Early warning signal indicators particularly sensitive cyclical data repeated non-linearity throughout year/cycle period interpreted transition initially, masking future cycles tipping points. therefore sensible deseason seasonal data prior assessment. EWSmethods provides suite average time series decomposition deseasoning techniques via deseason_ts() function. function takes n x m dataframe time series deaseasoned. first column must vector dates increment = order = arguments indicating data resolution (year, month, day) order date vector (ymd/dmy/ydm). form deseasoning can selected using method = argument. Lets create dummy monthly data can deseason.  multi_spp_data random, pronounced cycles sake tutorial, deseason_ts() applied :  method = \"stl\" argument shows chosen deseason using LOESS (locally weighted smoothing) estimating cyclical component time series subtracting . method = \"decompose\"/method = \"x11\" perform similar process use classical decomposition x11 ARIMA modelling (Ladiray & Quenneville, 2001) respectively. method = \"average\" simplest method average increment value estimated unique increment value subtracted data point shares increment key. deseason_ts() simply provides default procedure methods consequently visualising results deseason_ts() using downstream analyses. example, can see large monthly values shared across multiple years shrunk - e.g. black dashed species ~2001 - whereas anomalous values maintained - e.g. green dotted species ~2002.75.","code":"spp_data <- matrix(nrow = 5*12, ncol = 5)  seasonal_cycle <-  20*sin(2*pi*(1:5*12)/12)  spp_data <- sapply(1:dim(spp_data)[2], function(x){    spp_data[,x] <- ts(rnorm(5*12,mean = 20, sd = 3) + seasonal_cycle, freq = 12, start = c(2000, 1)) #add seasonal cycle to random noise      })  multi_spp_data <- cbind(\"time\" = base::seq(base::as.Date('2000/01/01'), base::as.Date('2004/12/01'), by = \"month\"), as.data.frame(spp_data))    matplot(x = multi_spp_data$time, y = multi_spp_data[,2:6], type = \"l\", xlab = \"Date\", ylab = \"Density\",  main = \"Seasonal five species community\") deseas_dat <- deseason_ts(data = multi_spp_data, increment = \"month\", method = \"average\", order = \"ymd\") #> data successfully aggregated into monthly time steps  matplot(x = deseas_dat$date, y = deseas_dat[,2:6], type = \"l\", xlab = \"Date\", ylab = \"Density\",  main = \"Deseasoned five species community\")"},{"path":"https://duncanobrien.github.io/EWSmethods/articles/ews_assessments.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Performing Early Warning Signal Assessments","text":"Clements, C.F. & Ozgul, . (2016) Including trait-based early warning signals helps predict population collapse. Nature Communications, 7, 10984. doi:10.1038/ncomms10984 Clements, C.F., McCarthy, M.. & Blanchard, J.L. (2019) Early warning signals recovery complex systems. Nature Communications, 10, 1681. doi:10.1038/s41467-019-09684-y Cleveland, R.B., Cleveland, W.S., McRae, J.E., & Terpenning, .J. (1990) STL: seasonal-trend decomposition procedure based loess. Journal Official Statistics, 6, 1, 3–33. http://bit.ly/stl1990 Dablander, F., Heesterbeek H., Borsboom D. & Drake J.M. (2022) Overlapping timescales obscure early warning signals second COVID-19 wave. Proceedings Royal Society B , 289, 20211809. doi:10.1098/rspb.2021.1809 Dakos, V. (2018) Identifying best-indicator species abrupt transitions multispecies communities. Ecological Indicators, 94, 494–502. doi:10.1016/j.ecolind.2017.10.024 Dakos, V., Carpenter, S.R., Brock, W.., Ellison, .M., Guttal, V., Ives, .R., et al. (2012) Methods detecting early warnings critical transitions time series illustrated using simulated ecological data. PLoS One, 7, e41010. doi:10.1371/journal.pone.0041010 Gama Dessavre, ., Southall, E., Tildesley, M.J. & Dyson, L. (2019) problem detrending analysing potential indicators disease elimination, Journal Theoretical Biology, 481, 183-193. doi:10.1016/j.jtbi.2019.04.011 Ladiray, D., & Quenneville, B. (2001) Seasonal Adjustment X-11 Method. Springer. doi:10.1007/978-1-4613-0175-2 Lenton T M., Livina V.N., Dakos V., van Nes E.H. & Scheffer M. (2012) Early warning climate tipping points critical slowing : comparing methods improve robustness Philosophical Transactions Royal Society 370, 1185–1204. doi:10.1098/rsta.2011.03047 O’Brien, D.. & Clements, C.F. (2021) Early warning signal reliability varies COVID-19 waves. Biology Letters, 17, 20210487. doi:10.1098/rsbl.2021.0487 Persons, W.M. (1919) General considerations assumptions. Review Economics Statistics, 1, 1,, 5–107. doi:10.2307/1928754 Southall E., Tildesley, M.J. & Dyson, L. (2022) early can upcoming critical transition detected? medRxiv 2022.05.27.22275693. doi:10.1101/2022.05.27.22275693 Weinans, E., Quax, R., van Nes, E.H. & van de Leemput, .. (2021) Evaluating performance multivariate indicators resilience loss. Scientific Reports, 11, 9148. 10.1038/s41598-021-87839-y","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/articles/using_ewsnet.html","id":"about-this-tutorial","dir":"Articles","previous_headings":"","what":"About this tutorial","title":"Using EWSNet","text":"tutorial introduces interface EWSNet, machine learning model trained predict critical transitions, tipping points, regime shifts (Deb et al. 2022). focus set R session interact EWSNet interpret output rather theory mathematics underlying model. interest details, please refer EWSNet specific website documentation associated publication. NOTE version EWSNet differs published Deb et al. (2022) retrained using range time series lengths (minimum = 15). improves accuracy EWSNet range time series lengths recommend minimum length tested 15 data points.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/articles/using_ewsnet.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"Using EWSNet","text":"EWSNet written developed Python, R interact , need exploit reticulate R package. reticulate provides tools run Python code R transfer objects two languages tends run much smoother RStudio rather base R. therefore recommended use RStudio IDE using EWSNet portion EWSmethods. following sections show setup run EWSNet EWSmethods troubleshooting common errors stemming Python-reticulate-R interface.","code":"set.seed(123) #to ensure reproducible data  library(EWSmethods)"},{"path":"https://duncanobrien.github.io/EWSmethods/articles/using_ewsnet.html","id":"initialising-ewsnet","dir":"Articles","previous_headings":"Getting started","what":"1. Initialising EWSNet","title":"Using EWSNet","text":"Rather requiring user learn reticulate setup R session , EWSmethods provides single function capable checking machine Python, installing ’s found (along critical packages), creating new Python environment hold packages, activating environment ready. prevent user accidentally installing Python packages, function require confirmation inputs user needs run start new R session. example, create new Python environment called \"EWSNET_env\" install Python, function written . environment name (\"EWSNET_env\") critical running later functions. successful, input \"y\" allow EWSmethods download activate Python environment now see message \"EWSNET_env successfully found activated. Necessary Python packages installed\"). , please refer Troubleshooting section end tutorial. double check environment activation, use reticulate functions check first environment active second Python packages loaded: EWSmethods also come bundled necessary model weights make predictions. due size weight files ~220 MB appropriate users package. download weights, can use ewsnet_reset() function can either remove -longer-needed weights re/download https://ewsnet.github.io. successful, input \"y\" allow EWSmethods download pretrained weights.","code":"#prepares your session using 'reticulate' and asks to install Anaconda (if no appropriate Python found) and/or a Python environment before activating that environment with the necessary Python packages ewsnet_init(envname = \"EWSNET_env\", pip_ignore_installed = FALSE,  conda_refresh = FALSE) library(reticulate)  #print which Python environment `EWSmethods` is using reticulate::py_config() #> python:         /usr/share/miniconda/envs/EWSNET_env/bin/python #> libpython:      /usr/share/miniconda/envs/EWSNET_env/lib/libpython3.8.so #> pythonhome:     /usr/share/miniconda/envs/EWSNET_env:/usr/share/miniconda/envs/EWSNET_env #> version:        3.8.13 (default, Mar 28 2022, 11:38:47)  [GCC 7.5.0] #> numpy:          /usr/share/miniconda/envs/EWSNET_env/lib/python3.8/site-packages/numpy #> numpy_version:  1.23.3 #>  #> NOTE: Python version was forced by use_python function  #list all packages currently loaded in to \"EWSNET_env\" py_packages <- reticulate::py_list_packages()  head(py_packages) #>         package version       requirement   channel #> 1 _libgcc_mutex     0.1 _libgcc_mutex=0.1 pkgs/main #> 2 _openmp_mutex     5.1 _openmp_mutex=5.1 pkgs/main #> 3       absl-py   1.2.0     absl-py=1.2.0      pypi #> 4     alabaster  0.7.12  alabaster=0.7.12      pypi #> 5    astunparse   1.6.3  astunparse=1.6.3      pypi #> 6         babel  2.10.3      babel=2.10.3      pypi ewsnet_reset(remove_weights = FALSE)"},{"path":"https://duncanobrien.github.io/EWSmethods/articles/using_ewsnet.html","id":"predictions-from-ewsnet","dir":"Articles","previous_headings":"Getting started","what":"2. Predictions from EWSNet","title":"Using EWSNet","text":"give example use ewsnet_predict() need test data. , use random noise around mean 0 expect predicted \"Transition\".  simply provide vector ewsnet_predict() also specifying Python environment, scaling data ensemble number (many models average prediction ).","code":"data(\"simTransComms\")  pre_simTransComms <- subset(simTransComms$`1_255_1`,time < inflection_pt)  plot(pre_simTransComms[,3], xlab = \"Year\", ylab = \"Density\") ewsnet_prediction <- ewsnet_predict(pre_simTransComms[,3], scaling = TRUE, ensemble = 25, envname = \"EWSNET_env\")   ewsnet_prediction #>                  pred no_trans_prob smooth_trans_prob critical_trans_prob #> 1 Critical Transition     0.2503765        0.06338059           0.6862429"},{"path":"https://duncanobrien.github.io/EWSmethods/articles/using_ewsnet.html","id":"interpreting-ewsnet","dir":"Articles","previous_headings":"Getting started > 2. Predictions from EWSNet","what":"Interpreting EWSNet","title":"Using EWSNet","text":"machine learning model, interpreting prediction probabilities difficult. EWSNet’s case, three possible predictions can made - transition, Smooth transition, Critical transition - chance prediction one approximately 0.33 (1.0 divided 3 ~0.33). Therefore probability greater 0.33 implies stronger chance prediction anything greater 0.6 warrants serious scrutiny. Similarly, real world manifestation Smooth Critical transition unclear (Kefi et al 2013, Gsell et al 2016). EWSNet therefore considers \"Smooth Transition\" prediction indicate directional trend system whereas \"Critical Transition\" indicates rapid non-linear change. \"Transition\" prediction consequently suggests stable period. figure visually depicts models used train predictions predictions relate time series data. Conceptual diagram ) type transitions EWSNet trained B) transitons can appear real time series data","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/articles/using_ewsnet.html","id":"predictions-through-time","dir":"Articles","previous_headings":"Getting started > 2. Predictions from EWSNet","what":"Predictions through time","title":"Using EWSNet","text":"additional way use EWSNet explore predictions change time. iteratively adding new data, can see predictions evolve. example, using test data, use code identify transitions may happened past:  see prediction probabilities fluctuate new data, trends probabilities also providing information system changed time.","code":"#define the range of indexes to test over expanding_range <- 50:length(pre_simTransComms[,3])   #pre-define our out file expanding_ewsnet <- data.frame(expanding_range, matrix(NA,ncol=3 )) |>   `colnames<-`(c(\"cutoff_ind\",\"No transition\",'Smooth','Critical'))   #call `ewsnet_predict()` for each index  for(i in seq_along(expanding_range)){    ews.tmp <- ewsnet_predict(pre_simTransComms[1:expanding_range[i],3],scaling = TRUE, ensemble = 25, envname = \"EWSNET_env\")       expanding_ewsnet[i,] <- c(expanding_range[i],ews.tmp$no_trans_prob,ews.tmp$smooth_trans_prob,ews.tmp$critical_trans_prob) }  #plot the results ggplot(expanding_ewsnet |> pivot_longer(-cutoff_ind,names_to = \"Prediction\",values_to = \"prob\"),                 aes(x=cutoff_ind,y=prob)) +     geom_point(aes(col=Prediction)) + theme_bw() +     xlab(\"Assessment index\") + ylab(\"Prediction probability\")"},{"path":"https://duncanobrien.github.io/EWSmethods/articles/using_ewsnet.html","id":"finetuning-ewsnet","dir":"Articles","previous_headings":"Getting started","what":"3. Finetuning EWSNet","title":"Using EWSNet","text":"circumstance training data available, may preferable finetune EWSNet. Finetuning alters EWSNet model weights based upon training data attempt improve predictions. example, user simulate collapsing time series length test data. EWSNet tuned identify features specific time series interest. example given using mock data set matched length pre_simTransComms - 191 data points. 25 scaled model weights resultingly finetuned based upon new training data. Calling ewsnet_predict(scaling = T) therefore use new weights. example, training data randomly generated, prediction quality decrease, however goes show weights can updated/improved new data comes available.","code":"x <- matrix(nrow = length(pre_simTransComms[,3]), ncol = 10)  x <- sapply(1:dim(x)[2], function(i){   x[,i] <- rnorm(length(pre_simTransComms[,3]),mean=20,sd=10)}) # create dummy data   y <- sample(0:2,10,replace = TRUE) # create labels. 0 = no transition, 1 = smooth transition, 2 = critical transition  ewsnet_finetune(x = x, y = y, scaling = TRUE, envname = \"EWSNET_env\")"},{"path":"https://duncanobrien.github.io/EWSmethods/articles/using_ewsnet.html","id":"resetting-ewsnet","dir":"Articles","previous_headings":"Getting started","what":"4. Resetting EWSNet","title":"Using EWSNet","text":"Following finetuning, may desirable reset model weights default. Using ewsnet_reset() function, user can direct EWSmethods path default weights (can redownloaded EWSNet github) overwrite current model weights stored EWSmethods. may want remove Python downloads environment setup EWSmethods /downloaded EWSNet weights. can achieve using ewsnet_init() conda_refresh = argument, ewsnet_reset() respectively.","code":"ewsnet_reset(remove_weights = FALSE) ewsnet_init(envname = \"EWSNET_env\",conda_refresh = TRUE) # removes Python, its packages and the \"EWSNET_env\" environment ewsnet_reset(remove_weights = TRUE) # removes any downloaded EWSNet weights"},{"path":"https://duncanobrien.github.io/EWSmethods/articles/using_ewsnet.html","id":"quick-reference","dir":"Articles","previous_headings":"","what":"Quick reference","title":"Using EWSNet","text":"Greater detail function can found Reference page.","code":""},{"path":[]},{"path":"https://duncanobrien.github.io/EWSmethods/articles/using_ewsnet.html","id":"reticulate-is-activating-a-different-environment-to-the-one-i-gave-to-ewsnet_init","dir":"Articles","previous_headings":"Troubleshooting","what":"1. reticulate is activating a different environment to the one I gave to ewsnet_init()","title":"Using EWSNet","text":"main error using EWSmethods. first solution simply restart R session rerun ewsnet_init(). reticulate loaded ewsnet_init() run, default reticulate environment \"r-reticulate\" activated instead EWSNet environment. Therefore ensure reticulate command library(reticulate) run prior ewsnet_init(). error remains RStudio version >=1.4, may need edit Python interpreter settings RStudio’s preferences. Go Preferences -> Python untick “Automatically activate project-level Python environments”. restart R session rerun ewsnet_init(). final solution aware involves deactivating reticulate’s default behaviour global R environment settings. Running bypass_reticulate_autoinit() disable reticulate’s ability load Python environment without user request. Restart R session rerun ewsnet_init() ready.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/articles/using_ewsnet.html","id":"ewsnet_predict-is-returning-python-errors","dir":"Articles","previous_headings":"Troubleshooting","what":"2. ewsnet_predict() is returning Python errors","title":"Using EWSNet","text":"errors extremely difficult debug R . Fortunately, experience, errors legacies previous issues incorrect initialising Python environment, crashing R session, killing running function. error therefore often solved restarting R session rerunning ewsnet_init(). error remains, please submit bug report .","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/articles/using_ewsnet.html","id":"i-want-to-uninstall-python-and-its-environments","dir":"Articles","previous_headings":"Troubleshooting","what":"3. I want to uninstall Python and its environments","title":"Using EWSNet","text":"ewsnet_init() provides capabaility using conda_refresh = argument: ewsnet_init(envname = \"envname\",conda_refresh = TRUE). function remove downloaded Python versions, packages environments allow fresh install permanent removal.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/articles/using_ewsnet.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Using EWSNet","text":"Deb S., Sidheekh S., Clements C.F., Krishnan N.C. & Dutta P.S. (2022) Machine learning methods trained simple models can predict critical transitions complex natural systems. Royal Society Open Science, 9, 211475. doi:10.1098/rsos.211475 Gsell , Scharfenberger U, Özkundakci D, Walters , Hansson LA, Janssen AB, Nõges P, Reid PC, Schindler DE, Van Donk E, Dakos V & Adrian R. (2016) Evaluating early-warning indicators critical transitions natural aquatic ecosystems. PNAS, 113(50):E8089-E8095. doi:10.1073/pnas.1608242113 Kéfi S., Dakos V., Scheffer M., Van Nes E.H. & Rietkerk, M. (2013) Early warning signals also precede non-catastrophic transitions. Oikos, 122: 641-648. doi:10.1111/j.1600-0706.2012.20838.x","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Duncan O'Brien. Author, maintainer, copyright holder. Smita Deb. Author. Sahil Sidheekh. Author. Partha Dutta. Author. Christopher Clements. Author.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"O'Brien D., Deb S. & Clements C.F (2022). EWSmethods: Pretty assessment univariate multivariate early warning signals. R package version 0.1.0 https://github.com/duncanobrien/EWSmethods.","code":"@Manual{,   title = {{EWSmethods}: Pretty assessment of univariate and multivariate early warning signals},   author = {Duncan A. O'Brien and Smita Deb and Christopher F Clements},   note = {R package version 0.1.0},   year = {2022},   url = {https://github.com/duncanobrien/EWSmethods},   doi = {10.5281/zenodo.6620844}, }"},{"path":"https://duncanobrien.github.io/EWSmethods/index.html","id":"ewsmethods-","dir":"","previous_headings":"","what":"Simple Early Warning Signals for Univariate and Multivariate Time Series","title":"Simple Early Warning Signals for Univariate and Multivariate Time Series","text":"EWSmethods user friendly interface various methods performing Early Warning Signal (EWS) assessments. R package allows user input univariate multivariate data perform either traditional rolling window (e.g. Dakos et al. 2012) expanding window (Drake Griffin, 2010) EWS approaches. Publication standard ggplot inspired figures can also generated process. EWSmethods also provides R interface EWSNet, deep learning modelling framework predicting critical transitions (Deb et al. 2022).","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Simple Early Warning Signals for Univariate and Multivariate Time Series","text":"can install development version EWSmethods GitHub : aware, due large file sizes EWSNet model weights (~230MB), EWSmethods come bundled . Users must download weights using ewsnet_init() ewsnet_reset() interfacing EWSNet.","code":"install.packages(\"devtools\") devtools::install_github(\"duncanobrien/EWSmethods\")"},{"path":"https://duncanobrien.github.io/EWSmethods/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting Started","title":"Simple Early Warning Signals for Univariate and Multivariate Time Series","text":"remainder page introduce two primary ways interacting EWSmethods critical transition forecasting needs. specific function help, please refer Reference page.","code":"library(EWSmethods)"},{"path":"https://duncanobrien.github.io/EWSmethods/index.html","id":"1-early-warning-signals","dir":"","previous_headings":"","what":"1. Early Warning Signals","title":"Simple Early Warning Signals for Univariate and Multivariate Time Series","text":"Early warning signals collection summary statistics attempt characterise phenomenon critical slowing (CSD). system approaches tipping point (bifurcation), takes longer longer recover pushed away stability (Dakos et al. 2012). increased return rate manifestation CSD can detectable data. EWSmethods provides collection summary statistics can calculated either univariate multivariate time series using uniEWS() multiEWS() respectively.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/index.html","id":"the-univariate-approach","dir":"","previous_headings":"1. Early Warning Signals","what":"The univariate approach","title":"Simple Early Warning Signals for Univariate and Multivariate Time Series","text":"Imagine 50 years monitoring data local population skylarks (Alauda arvensis) measured mean body mass data throughout period well. calculate either rolling expanding window EWSs using abundance data via uniEWS() decide initially focus rolling windows. therefore parameterise function : can use resulting figures identify oncoming transitions. case, expect transition data randomly sampled normal distribution evident Kendall Tau values, strong positive correlation time:  Alternatively, may interested expanding windows approach standardises changing EWS metrics time therefore allows strength multiple signals combined. achieve using following code: , can use resulting figures identify oncoming transitions. Whilst trangressions 2σ threshold, consider signals “warnings” two consecutive signals identified (Clements et al. 2019).  second benefit expanding window approach additional information can used improve reliability assessment. Including trait information shown decrease likelihood false positive false negative signals (Clements Ozgul, 2016; Baruah et al. 2019) therefore considered possible. example, hypothetical skylark dataset, measured average population body mass. data can delivered univariate_EWS_wrapper() function EWSmethods, using trait argument.","code":"set.seed(125) #seed to ensure reproducible results  skylark_data <- data.frame(time = seq(1:50), abundance = rnorm(50,mean = 100,sd=20), trait = rnorm(50,mean=40,sd=5)) #dummy skylark dataset  ews_metrics <- c(\"SD\",\"ar1\",\"skew\") #the early warning signal metrics we wish to compute  roll_ews <- uniEWS(data = skylark_data[,1:2], metrics =  ews_metrics, method = \"rolling\", winsize = 50, ggplotIt =TRUE,  y_lab = \"Skylark abundance\") #lets use a rolling window approach  roll_ews$EWS$cor #return the Kendall Tau correlations for each EWS metric #>            SD        ar1       skew #> tau 0.5446154 -0.3907692 -0.7046154 exp_ews <- uniEWS(data = skylark_data[,1:2], metrics =  ews_metrics, method = \"expanding\", burn_in = 10, threshold = 2,  tail.direction = \"one.tailed\", ggplotIt =TRUE, y_lab = \"Skylark abundance\") #lets use a rolling window approach #> Warning: Removed 7 row(s) containing missing values (geom_path). #> Warning: Removed 7 rows containing missing values (geom_point).  head(exp_ews$EWS) #return the head of the EWS dataframe #>   time metric.score metric.code rolling.mean rolling.sd threshold.crossed #> 1   10    0.0000000         ar1    0.0000000         NA                 0 #> 2   11   -0.7071068         ar1   -0.3535534  0.5000000                 0 #> 3   12   -0.9223669         ar1   -0.5431579  0.4825449                 0 #> 4   13   -0.1500572         ar1   -0.4448827  0.4403012                 0 #> 5   14    0.8428688         ar1   -0.1873324  0.6906950                 0 #> 6   15   -1.8668306         ar1   -0.4672488  0.9229121                 0 #>   count.used        str #> 1  108.91249         NA #> 2   93.56813 -0.7071068 #> 3  109.56960 -0.7858522 #> 4  103.92341  0.6695997 #> 5  114.29655  1.4915428 #> 6   80.79726 -1.5164845 trait_metrics <- c(\"SD\", \"ar1\", \"trait\") exp_ews_trait <- uniEWS(data = skylark_data[,1:2], metrics =  trait_metrics, method = \"expanding\", burn_in = 10, threshold = 2, tail.direction = \"one.tailed\", ggplotIt =TRUE, y_lab = \"Skylark abundance\", trait = skylark_data$trait, trait_lab = \"Body mass (g)\", trait_scale = 5) #> Warning: Removed 7 row(s) containing missing values (geom_path). #> Warning: Removed 7 rows containing missing values (geom_point)."},{"path":"https://duncanobrien.github.io/EWSmethods/index.html","id":"the-multivariate-approach","dir":"","previous_headings":"1. Early Warning Signals","what":"The multivariate approach","title":"Simple Early Warning Signals for Univariate and Multivariate Time Series","text":"data multiple timeseries/measurements system, might interested multivariate early warning signals. indicators exploit either dimension reduction techniques (Principal Component Analysis) community average estimates give overall measure system resilience (see Weinans et al. 2021 overview indicator). ’ve constructed another hypothetical dataset representing five related populations Caribbean reef octopus (Octopus briareus) Bahamian salt water lakes (O’Brien et al. 2020) interested assessing resilience metapopulation. following code shows achieve using EWSmethods function multiEWS(). figure shows one multivariate EWS indicator expressed warning, overall, transition anticipated.","code":"set.seed(123)  octopus_spp_data <- matrix(nrow = 50, ncol = 5) octopus_spp_data <- as.data.frame(cbind(\"time\"=seq(1:50),sapply(1:dim(octopus_spp_data)[2], function(x){octopus_spp_data[,x] <- rnorm(50,mean=500,sd=200)}))) #create our hypothetical, uncollapsing ecosystem  oct_exp_ews <- multiEWS(data = octopus_spp_data, method = \"expanding\", threshold = 2, tail.direction = \"one.tailed\", ggplotIt = TRUE) #lets use an expanding window approach #> Warning: Removed 24 row(s) containing missing values (geom_path). #> Warning: Removed 24 rows containing missing values (geom_point)."},{"path":"https://duncanobrien.github.io/EWSmethods/index.html","id":"2-ewsnet","dir":"","previous_headings":"","what":"2. EWSNet","title":"Simple Early Warning Signals for Univariate and Multivariate Time Series","text":"half EWSmethods allows query Python-based EWSNet via easy use R workflow. simple example details first prepare R session communicate Python (using excellent reticulate R package) calls EWSNet assess probability transition occurring skylark time series. two step process must ) call ewsnet_init() b) using ewsnet_predict(). However, first time using EWSNet via EWSmethods, must first download pretrained model weights https://ewsnet.github.io. Now can setup R session interface EWSNet.","code":"ewsnet_reset(remove_weights = FALSE, auto = T) #> Model weights downloaded ewsnet_init(envname = \"EWSNET_env\", auto = T) #prepares your workspace using 'reticulate' and asks to install Anaconda (if no appropriate Python found) and/or a Python environment before activating that environment with the necessary Python packages #> Attention: may take up to 10 minutes to complete #> EWSNET_env successfully found and activated. Necessary python packages installed  library(reticulate)  reticulate::py_config() #confirm that \"EWSNET_env\" has been loaded #> python:         /Users/ul20791/Library/r-miniconda-arm64/envs/EWSNET_env/bin/python #> libpython:      /Users/ul20791/Library/r-miniconda-arm64/envs/EWSNET_env/lib/libpython3.8.dylib #> pythonhome:     /Users/ul20791/Library/r-miniconda-arm64/envs/EWSNET_env:/Users/ul20791/Library/r-miniconda-arm64/envs/EWSNET_env #> version:        3.8.13 | packaged by conda-forge | (default, Mar 25 2022, 06:05:16)  [Clang 12.0.1 ] #> numpy:          /Users/ul20791/Library/r-miniconda-arm64/envs/EWSNET_env/lib/python3.8/site-packages/numpy #> numpy_version:  1.23.3 #>  #> NOTE: Python version was forced by use_python function  py_packages <- reticulate::py_list_packages() #list all packages currently loaded in to \"EWSNET_env\" head(py_packages) #>           package     version                 requirement     channel #> 1         absl-py       1.2.0               absl-py=1.2.0        pypi #> 2       alabaster      0.7.12            alabaster=0.7.12        pypi #> 3      astunparse       1.6.3            astunparse=1.6.3        pypi #> 4           babel      2.10.3                babel=2.10.3        pypi #> 5           bzip2       1.0.8                 bzip2=1.0.8 conda-forge #> 6 ca-certificates 2022.6.15.1 ca-certificates=2022.6.15.1 conda-forge  skylark_ewsnet <- ewsnet_predict(skylark_data$abundance, scaling = TRUE, ensemble = 25, envname = \"EWSNET_env\") #perform EWSNet assessment using white noise and all 25 models. The envname should match ewsnet_init()  skylark_ewsnet #>                pred no_trans_prob smooth_trans_prob critical_trans_prob #> 1 Smooth Transition    0.01527405         0.9658694          0.01885661"},{"path":"https://duncanobrien.github.io/EWSmethods/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Simple Early Warning Signals for Univariate and Multivariate Time Series","text":"Baruah, G., Clements, C.F., Guillaume, F. & Ozgul, . (2019) shifts trait dynamics precede population declines? American Naturalist, 193, 633–644. doi:10.1086/702849 Clements, C.F. & Ozgul, . (2016) Including trait-based early warning signals helps predict population collapse. Nature Communications, 7, 10984. doi:10.1038/ncomms10984 Clements, C.F., McCarthy, M.. & Blanchard, J.L. (2019) Early warning signals recovery complex systems. Nature Communications, 10, 1681. doi:10.1038/s41467-019-09684-y Dakos V., Carpenter S.R., Brock W.., Ellison .M., Guttal V., et al. (2012) Methods detecting early warnings critical transitions time series illustrated using simulated ecological data. PLOS ONE, 7, 7:e41010. doi:10.1371/journal.pone.0041010 Deb S., Sidheekh S., Clements C.F., Krishnan N.C. & Dutta P.S. (2022) Machine learning methods trained simple models can predict critical transitions complex natural systems. Royal Society Open Science, 9, 211475. doi:10.1098/rsos.211475 Drake, J. & Griffen, B. (2010) Early warning signals extinction deteriorating environments. Nature, 467, 456–459. doi:10.1038/nature09389 O’Brien, D.., Taylor, M.L., Masonjones, H.D., Boersch-Supan P.H. & O’Shea, O.R. (2020) Drivers octopus abundance density anchialine lake: 30 year comparison. Journal Experimental Marine Biology Ecology, 528, 151377. doi:10.1016/j.jembe.2020.151377 Weinans, E., Quax, R., van Nes, E.H. & van de Leemput, .. (2021) Evaluating performance multivariate indicators resilience loss. Scientific Reports, 11, 9148. 10.1038/s41598-021-87839-y","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/CODrecovery.html","id":null,"dir":"Reference","previous_headings":"","what":"Three Recovering Cod Populations — CODrecovery","title":"Three Recovering Cod Populations — CODrecovery","text":"dataset containing three simulated cod populations. Community 1 recovery whereas Community 100 200 .","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/CODrecovery.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Three Recovering Cod Populations — CODrecovery","text":"","code":"CODrecovery"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/CODrecovery.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Three Recovering Cod Populations — CODrecovery","text":"list three dataframes 191 rows 6 variables : community_id identity simulated community time time index biomass population total biomass mean.size average length cod individuals sd.size variation length cod individuals inflection_pt time index transition occurs","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/CODrecovery.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Three Recovering Cod Populations — CODrecovery","text":"Clements C., McCarthy M., Blanchard J. (2019) Early warning signals recovery complex systems. Nature Communications, 10:1681.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/EWSNET_init.html","id":null,"dir":"Reference","previous_headings":"","what":"EWSNet Initialisation — ewsnet_init","title":"EWSNet Initialisation — ewsnet_init","text":"Prepares R session communicating Python. function first searches computer appropriate Python environment activates , importing vital Python packages required. appropriate Python install environment found, asking permission, miniconda downloaded environment created.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/EWSNET_init.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"EWSNet Initialisation — ewsnet_init","text":"","code":"ewsnet_init(   envname,   pip_ignore_installed = FALSE,   conda_refresh = FALSE,   auto = FALSE )"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/EWSNET_init.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"EWSNet Initialisation — ewsnet_init","text":"envname string naming desired Python environment create/activate. Python environment found, functions prompts install miniconda required python packages. pip_ignore_installed Boolean. FALSE, packages already installed loaded re-downloaded. However, TRUE, packages downloaded irregardless, overwriting version already present (analagous updating required). conda_refresh Boolean. TRUE, miniconda uninstalled gives user opportunity perform fresh reinstall. auto Boolean. TRUE, user confirmation required activation.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/EWSNET_init.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"EWSNet Initialisation — ewsnet_init","text":"return object simply preparing R session.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/EWSNET_init.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"EWSNet Initialisation — ewsnet_init","text":"","code":"if (FALSE) { bypass_reticulate_autoinit() } #this function prevents 'reticulate' automatically #reloading the python environment from the #previous session. Only needs to be run once #on first install of 'EWSmethods'.  if (FALSE) { ewsnet_init(envname = \"EWSNET_env\") } #Common errors at this stage result from 'reticulate's #behaviour. For example, conflicts between 'ewsnet_init' #and RETICULATE_PYTHON may occur if run inside a #RStudio R project. To fix this, navigate to #Preferences -> Python, untick 'Automatically #activate project-local Python environments' #and restart R.  if (FALSE) { reticulate::py_config() } #If successful, 'EWSNET_env forced by use_python #function' will be printed."},{"path":"https://duncanobrien.github.io/EWSmethods/reference/FI.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Fisher Information — FI","title":"Calculate Fisher Information — FI","text":"Uses multivariate array time series estimate Fisher information following approach Karunanithi et al. (2010).","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/FI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Fisher Information — FI","text":"","code":"FI(timedat, data, sost, winsize, winspace = 1, TL = 90)"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/FI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Fisher Information — FI","text":"timedat numeric vector equal spacing representing time points data numeric matrix individual time series across columns. different species, populations measurements. sost 1 x n matrix n length equal number time series data. value 'size state' tolerable time series typically represented standard deviation time series reference period. winsize Numeric value. Defines window size rolling window percentage time series length. winspace Numeric value. number data points roll window iteration. Must less winsize. TL Numeric value. 'tightening level' percentage points shared states allows algorithm classify data points state.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/FI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Fisher Information — FI","text":"list containing three objects: FI numeric vector Fisher information estimates midt_win numeric vector time index centre window associated value FI. t_win n x m numeric matrix length n winspace length m number window shifts made. Values consequently timepoint indices contribute window.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/FI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Fisher Information — FI","text":"","code":"#Load the multivariate simulated #dataset `simTransComms`  data(simTransComms)  #Estimate the size-of-states for each #time series in the \"1_5_1\" community. #This is typically suggested #to be the standard deviation of a #reference period or the entire time #series  eg.sost <- apply(simTransComms$`1_5_1`[,3:7], MARGIN = 2, FUN = sd) |> t() #transpose required to ensure a 1 x n matrix  egFI <- FI(timedat = simTransComms$`1_5_1`$time, data = simTransComms$`1_5_1`[,3:7], sost =  eg.sost, winsize = 10, winspace = 1, TL = 90)"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/bypass_reticulate_autoinit.html","id":null,"dir":"Reference","previous_headings":"","what":"Prevent Reticulate Autoconfiguring Python environments — bypass_reticulate_autoinit","title":"Prevent Reticulate Autoconfiguring Python environments — bypass_reticulate_autoinit","text":"Adds RETICULATE_AUTOCONFIGURE = \"FALSE\" .Renviron prevent reticulate automatically loading Python environments.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/bypass_reticulate_autoinit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prevent Reticulate Autoconfiguring Python environments — bypass_reticulate_autoinit","text":"","code":"bypass_reticulate_autoinit()"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/deseason_ts.html","id":null,"dir":"Reference","previous_headings":"","what":"Deseason Seasonal Time Series — deseason_ts","title":"Deseason Seasonal Time Series — deseason_ts","text":"Removes seasonal signals time series using either averaging time series decomposition methods. Three decomposition methods available: traditional decompostion, loess decomposition X11 decompostion.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/deseason_ts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deseason Seasonal Time Series — deseason_ts","text":"","code":"deseason_ts(   data,   increment = c(\"month\", \"year\", \"week\", \"day\"),   method = c(\"average\", \"decompose\", \"stl\", \"x11\"),   order = NULL )"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/deseason_ts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deseason Seasonal Time Series — deseason_ts","text":"data dataframe transformed, first column must vector dates columns individual time series. increment time-step increment either month, year, week, day. Provides basis deaseasoning. method String either \"average\", \"decompose\", \"stl\" \"x11\" indicating method deseasoning. \"average\" subtracts average representative month/week/day---year time point whereas \"decompose\", \"stl\" \"x11\" subtracts seasonal component estimated time series decomposition, loess decomposition X11 method respectively. order String indicating date format date columns. Options \"dmy\", \"ymd\" \"mdy\".","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/deseason_ts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deseason Seasonal Time Series — deseason_ts","text":"Dataframe deseasoned time series.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/deseason_ts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deseason Seasonal Time Series — deseason_ts","text":"","code":"#Generate five random monthly time series #of 5 years length.  spp_data <- matrix(nrow = 5*12, ncol = 5) spp_data <- sapply(1:dim(spp_data)[2], function(x){ spp_data[,x] <- rnorm(5*12,mean=20,sd=5)}) multi_spp_data <- cbind(\"time\" =  seq(as.Date('2000/01/01'), as.Date('2004/12/01'), by=\"month\"),    as.data.frame(spp_data))  #Deseason using time series #decomposition.  decomp_dat <- deseason_ts(data = multi_spp_data, increment = \"month\", method = \"decompose\", order = \"ymd\") #> data successfully aggregated into monthly time steps  #Deseason using loess  decomp_dat <- deseason_ts(data = multi_spp_data, increment = \"month\", method = \"stl\", order = \"ymd\") #> data successfully aggregated into monthly time steps"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/detrend_ts.html","id":null,"dir":"Reference","previous_headings":"","what":"Detrend Time Series — detrend_ts","title":"Detrend Time Series — detrend_ts","text":"Removes directional signals time series using loess, linear regression gaussian detrending.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/detrend_ts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detrend Time Series — detrend_ts","text":"","code":"detrend_ts(data, method = \"linear\", bandwidth = NULL, span = 0.25, degree = 2)"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/detrend_ts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detrend Time Series — detrend_ts","text":"data dataframe detrended. first column must vector dates columns individual time series. method method detrending. Options include \"linear\" (residuals linear regression), loess (smoothing local polynomial regression), gaussian (smoothing gaussian kernel), first.difference. bandwidth method = \"gaussian\", dictates bandwidth gaussian kernel. NULL, estimated data. span method = \"loess\", controls degree smoothing proportion points used (span = 1, points used) degree method = \"loess\", specifies degree polynomials allowed. Options normally 1 2.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/detrend_ts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detrend Time Series — detrend_ts","text":"Dataframe deseasoned time series.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/detrend_ts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detrend Time Series — detrend_ts","text":"","code":"#Generate five random monthly time series #of 5 years length.  spp_data <- matrix(nrow = 5*12, ncol = 5) spp_data <- sapply(1:dim(spp_data)[2], function(x){ spp_data[,x] <- rnorm(5*12,mean=20,sd=5)}) multi_spp_data <- cbind(\"time\" =  seq(as.Date('2000/01/01'), as.Date('2004/12/01'), by=\"month\"),    as.data.frame(spp_data))  detrend_dat <- detrend_ts(data = multi_spp_data, method = \"gaussian\", bandwidth = 2)"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/ewsnet_finetune.html","id":null,"dir":"Reference","previous_headings":"","what":"EWSNet Finetune — ewsnet_finetune","title":"EWSNet Finetune — ewsnet_finetune","text":"Communicates EWSNet (https://ewsnet.github.io), deep learning framework modelling anticipating regime shifts dynamical systems, finetunes model match inputted training data. overwrites Pretrained weights bundled EWSmethods. See reset_ewsnet() reset trained weights.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/ewsnet_finetune.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"EWSNet Finetune — ewsnet_finetune","text":"","code":"ewsnet_finetune(x, y, scaling = TRUE, envname)"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/ewsnet_finetune.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"EWSNet Finetune — ewsnet_finetune","text":"x numeric matrix finetune EWSNet . column represents separate timeseries row timestep. y numeric vector consisting target labels training time series. Labels include: 0 (transition), 1 (smooth transition) 2 (critical transition). scaling Boolean.  TRUE, time series scaled 1 2 scaled EWSNet model weights used. recommended setting. envname string naming Python environment prepared ewsnet_init().","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/ewsnet_finetune.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"EWSNet Finetune — ewsnet_finetune","text":"","code":"#Activate python environment (only necessary #on first opening of R session).  if (FALSE) { ewsnet_init(envname = \"EWSNET_env\") }  #A dummy dataset of a hedgerow bird population #monitored over 50 years that needs to be tuned.  abundance_data <- data.frame(time = seq(1:50),  abundance = rnorm(50,mean = 20))  #Generate training data (this is random data as #an example).  x <- matrix(nrow = 50, ncol = 10) x <- sapply(1:dim(x)[2], function(i){  x[,i] <- rnorm(50,mean=20,sd=10)})  #Label each time series.  y <- sample(0:2,10,replace = TRUE)  #Finetune EWSNet.  if (FALSE) { ewsnet_finetune(  x = x,  y = y,  scaling = TRUE,  envname = \"EWSNET_env\")  }  #Generate new EWSNet predictions.  if (FALSE) { pred <- ewsnet_predict(  abundance_data$abundance,  scaling = TRUE,  ensemble = 15,  envname = \"EWSNET_env\")  }"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/ewsnet_predict.html","id":null,"dir":"Reference","previous_headings":"","what":"EWSNet Predict — ewsnet_predict","title":"EWSNet Predict — ewsnet_predict","text":"Communicates EWSNet (https://ewsnet.github.io), deep learning framework modelling anticipating regime shifts dynamical systems, returns model's prediction inputted univariate time series.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/ewsnet_predict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"EWSNet Predict — ewsnet_predict","text":"","code":"ewsnet_predict(x, scaling = TRUE, ensemble = 25, envname)"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/ewsnet_predict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"EWSNet Predict — ewsnet_predict","text":"x numeric vector values tested. scaling Boolean.  TRUE, time series scaled 1 2 scaled EWSNet model weights used. recommended setting. ensemble numeric value stating number models average . Options range 1 25. envname string naming Python environment prepared ewsnet_init().","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/ewsnet_predict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"EWSNet Predict — ewsnet_predict","text":"dataframe EWSNet predictions. Values represent estimated probability quoted event occur.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/ewsnet_predict.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"EWSNet Predict — ewsnet_predict","text":"","code":"#A dummy dataset of a hedgerow bird population #monitored over 50 years.  abundance_data <- data.frame(time = seq(1:50),  abundance = rnorm(50,mean = 20))  #Activate python environment (only necessary #on first opening of R session).  if (FALSE) { ewsnet_init(envname = \"EWSNET_env\") }  #Generate EWSNet predictions.  if (FALSE) { pred <- ewsnet_predict(  abundance_data$abundance,  scaling = TRUE,  ensemble = 15,  envname = \"EWSNET_env\")  }"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/ewsnet_reset.html","id":null,"dir":"Reference","previous_headings":"","what":"Reset EWSNet Model Weights — ewsnet_reset","title":"Reset EWSNet Model Weights — ewsnet_reset","text":"Restores EWSNet model weights pretrained defaults published https://ewsnet.github.io. vital first use EWSNet model weights provided `EWSmethods`. use function may also necessary finetuning reset model.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/ewsnet_reset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reset EWSNet Model Weights — ewsnet_reset","text":"","code":"ewsnet_reset(remove_weights = FALSE, auto = FALSE)"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/ewsnet_reset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reset EWSNet Model Weights — ewsnet_reset","text":"remove_weights Boolean. weights removed (TRUE) weights re/downloaded (FALSE). auto Boolean. TRUE, user confirmation required re/download.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/ewsnet_reset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reset EWSNet Model Weights — ewsnet_reset","text":"","code":"if (FALSE) { ewsnet_reset(remove_weights = FALSE, auto = FALSE) # on first use of EWSNet via `EWSmethods` }  if (FALSE) { ewsnet_reset(remove_weights = TRUE) # to remove all downloaded weights }"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/multiEWS.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate Early Warning Signal Assessment — multiEWS","title":"Multivariate Early Warning Signal Assessment — multiEWS","text":"single function performing early warning signal (EWS) assessment multivariate systems multiple time series measured. methods EWS assessment can performed (rolling expanding windows) assessments returned dataframe without standardised ggplot-based figure. two methods dimension reduction used perform assessments Principal Component Analysis Maximum/Minimum Autocorrelation Factors.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/multiEWS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate Early Warning Signal Assessment — multiEWS","text":"","code":"multiEWS(   data,   metrics = c(\"meanAR\", \"maxAR\", \"meanSD\", \"maxSD\", \"eigenMAF\", \"mafAR\", \"mafSD\",     \"pcaAR\", \"pcaSD\", \"eigenCOV\", \"maxCOV\", \"mutINFO\"),   method = c(\"expanding\", \"rolling\"),   ggplotIt = TRUE,   winsize = 50,   burn_in = 5,   threshold = 2,   tail.direction = \"one.tailed\" )"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/multiEWS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate Early Warning Signal Assessment — multiEWS","text":"data dataframe first column equally spaced time vector columns individual time series. different species, populations measurements. metrics String vector early warning signal metrics assessed.  Options include: \"meanSD\", \"maxSD\", \"meanAR\", \"maxAR\", \"eigenMAF\", \"mafAR\", \"mafSD\", \"pcaAR\", \"pcaSD\", \"eigenCOV\", \"maxCOV\" \"mutINFO\". method Single string either \"expanding\" \"rolling\". \"expanding\" calls composite, expanding window EWS assessment. \"rolling\" calls typical, rolling window EWS assessment. ggplotIt Boolean. TRUE, returns ggplot plot EWS strength trends estimated dimension reduction. winsize Numeric value. method = \"rolling\", defines window size rolling window percentage time series' length. burn_in Numeric value. method = \"expanding\", defines number data points 'train' signals prior EWS assessment. threshold Numeric value either 1 2. Threshold*sigma value , EWS strength exceeds , constitutes \"signal\". tail.direction String either \"one.tailed\" \"two.tailed\". \"one.tailed\" indicates warning positive threshold sigma exceeded. \"two.tailed\" indicates warning positive negative threshold*sigma exceeded.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/multiEWS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate Early Warning Signal Assessment — multiEWS","text":"list containing two objects: EWS outputs time (EWS), plot object (plot) ggplotIt = TRUE. EWS$raw Dataframe EWS measurements time. method = \"expanding\", metric rbound single dataframe extra columns provided indicating whether threshold*sigma value exceeded (.e. \"threshold.crossed\"). method = \"expanding\", metric's evolution time returned individual columns. EWS$dimred.ts Dataframe containing dimension reduction time series EWS$cor Dataframe Kendall Tau correlations. returned method = \"rolling\". plot Plot object. returned ggplotIt = \"TRUE\".","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/multiEWS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multivariate Early Warning Signal Assessment — multiEWS","text":"","code":"#Generate a random five species, non-transitioning #ecosystem with 50 years of monitoring data.  spp_data <- matrix(nrow = 50, ncol = 5) spp_data <- sapply(1:dim(spp_data)[2], function(x){  spp_data[,x] <- rnorm(50,mean=20,sd=5)})  multi_spp_data <- as.data.frame(cbind(\"time\" =  seq(1:50), spp_data))  #Rolling window early warning signal assessment of #the ecosystem, without plotting.  roll_ews <- multiEWS(  data = multi_spp_data,  method = \"rolling\",  winsize = 50,  ggplotIt =FALSE) #> Warning: Cannot compute exact p-value with ties  #Expanding window early warning signal assessment of #the ecosystem, with plotting.  if (FALSE) { exp_ews <- multiEWS(  data = multi_spp_data,  method = \"expanding\",  burn_in = 10,  ggplotIt = TRUE)  }"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/mvi.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate Variance Index function — mvi","title":"Multivariate Variance Index function — mvi","text":"Calculate multivariate variance following Brock, W. ., S. R. Carpenter. 2006. Variance leading indicator regime shift ecosystem services. Ecology Society 11(2): 9.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/mvi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate Variance Index function — mvi","text":"","code":"mvi(data, winsize)"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/mvi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate Variance Index function — mvi","text":"data numeric matrix species abundances, names across columns, time across rows winsize Numeric. Defines window size rolling window percentage time series length.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/mvi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate Variance Index function — mvi","text":"matrix first column last time index window second column estimated index value.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/mvi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multivariate Variance Index function — mvi","text":"","code":"#Load the multivariate simulated #dataset `simTransComms`  data(simTransComms)  #Estimate the MVI for the \"1_38_1\" community  egMVI <- mvi(data = simTransComms$`1_38_1`[,3:7], winsize = 10)"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/simTransComms.html","id":null,"dir":"Reference","previous_headings":"","what":"Three Simulated Transitioning Communities. — simTransComms","title":"Three Simulated Transitioning Communities. — simTransComms","text":"dataset containing three simulated five species communities stressed critical transition.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/simTransComms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Three Simulated Transitioning Communities. — simTransComms","text":"","code":"simTransComms"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/simTransComms.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Three Simulated Transitioning Communities. — simTransComms","text":"list three dataframes 301 rows 7 variables : community_id identity simulated community time time index spp_1 density species 1 spp_2 density species 1 spp_3 density species 1 spp_4 density species 1 spp_5 density species 1 inflection_pt time index transition occurs","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/uniEWS.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariate Early Warning Signal Assessment — uniEWS","title":"Univariate Early Warning Signal Assessment — uniEWS","text":"function performing early warning signal (EWS) assessment univariate time series. rolling expanding window methods EWS assessment can performed assessments returned dataframe without standardised ggplot-based figure.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/uniEWS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Univariate Early Warning Signal Assessment — uniEWS","text":"","code":"uniEWS(   data,   metrics,   method = c(\"expanding\", \"rolling\"),   ggplotIt = TRUE,   y_lab = \"Generic indicator name\",   winsize = 50,   burn_in = 5,   threshold = 2,   tail.direction = \"one.tailed\",   trait = NULL,   trait_lab = \"Generic Trait Name\",   trait_scale = 1000 )"},{"path":"https://duncanobrien.github.io/EWSmethods/reference/uniEWS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Univariate Early Warning Signal Assessment — uniEWS","text":"data dataframe first column equally spaced time vector second column time series assessed. metrics String vector early warning signal metrics assessed.  Options include: \"ar1\", \"cv\", \"SD\", \"acf\", \"rr\", \"dr\", \"skew\", \"kurt\", \"trait\". method Single string either \"expanding\" \"rolling\". \"expanding\" calls composite, expanding window EWS assessment. \"rolling\" calls typical, rolling window EWS assessment. ggplotIt Boolean. TRUE, returns ggplot plot EWS strength trends input abundance. y_lab String label. ggplotIt = TRUE, labels abundance y axis. winsize Numeric value. method = \"rolling\", defines window size rolling window percentage time series length. burn_in Numeric value. method = \"expanding\", defines number data points 'train' signals prior EWS assessment. threshold Numeric value either 1 2. Threshold*sigma value , EWS strength exceeds , constitutes \"signal\". tail.direction String either \"one.tailed\" \"two.tailed\". \"one.tailed\" indicates warning positive threshold sigma exceeded. \"two.tailed\" indicates warning positive negative threshold*sigma exceeded. trait vector numeric trait values desired. Can NULL trait_lab String label. ggplotIt = TRUE, & trait populated, & \"trait\" supplied metrics, labels right side y axis represents trait values time. trait_scale Numeric value. Scales trait y axis relative abundance y axis.","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/uniEWS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Univariate Early Warning Signal Assessment — uniEWS","text":"list containing two objects: EWS outputs time (EWS), plot object (plot) ggplotIt = TRUE. EWS$raw Dataframe EWS measurements time. method = \"expanding\", metric rbound single dataframe extra columns provided indicating whether threshold*sigma value exceeded (.e. \"threshold.crossed\"). method = \"expanding\", metric's evolution time returned individual columns. EWS$cor Dataframe Kendall Tau correlations. returned method = \"rolling\". plot Plot object. returned ggplotIt = \"TRUE\".","code":""},{"path":"https://duncanobrien.github.io/EWSmethods/reference/uniEWS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Univariate Early Warning Signal Assessment — uniEWS","text":"","code":"#A dummy dataset of a hedgerow bird population over #50 years where both the number of individuals and #the average bill length has been measured.  abundance_data <- data.frame(time = seq(1:50),  abundance = rnorm(50,mean = 20),  trait = rnorm(50,mean=1,sd=0.5))  #The early warning signal metrics to compute.  ews_metrics <- c(\"SD\",\"ar1\",\"skew\")  #Rolling window early warning signal assessment of #the bird abundance (no plotting).  roll_ews <- uniEWS(  data = abundance_data[,1:2],  metrics =  ews_metrics,  ggplotIt = FALSE,  method = \"rolling\",  winsize = 50)  #Expanding window early warning signal assessment of #the bird abundance (with plotting).  if (FALSE) { exp_ews <- uniEWS(  data = abundance_data,  metrics = ews_metrics,  method = \"expanding\",  burn_in = 10,  ggplotIt = TRUE,  y_lab = \"Bird abundance\")  }  #Expanding window early warning signal assessment of #the bird abundance incorporating the trait #information (with plotting).  ews_metrics_trait <- c(\"SD\",\"ar1\",\"trait\") if (FALSE) { trait_exp_ews <- uniEWS(  data = abundance_data,  metrics = ews_metrics_trait,  method = \"expanding\",  burn_in = 10,  ggplotIt = TRUE,  trait = abundance_data$trait,  trait_lab = \"Bill length (mm)\",  trait_scale = 10)  }"}]
